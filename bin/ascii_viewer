#!/usr/bin/env python3

import sys
import os
rootdir = os.path.abspath(os.path.join(os.path.dirname(__file__), os.pardir))
sys.path.append(rootdir)

import argparse
import asyncio
import functools

import config
import client
import aui

from monitor.trace_log import TraceLog


class Timer:

    def __init__(self, timeout, callback, repeat=False):
        self.timeout = timeout
        self.callback = callback
        self.repeat = repeat
        self.task = asyncio.ensure_future(self.job())

    async def job(self):
        try:
            await asyncio.sleep(self.timeout)
        except asyncio.exceptions.CancelledError:
            return
        await self.callback()
        if self.repeat:
            self.task = asyncio.ensure_future(self.job())

    def cancel(self):
        self.repeat = False
        self.task.cancel()


class ViewerClient:
    cmd_translate = {
        "f": "forward",
        "r": "right",
        "l": "left",
    }

    def __init__(self, viewer_screen):
        self.viewer_screen = viewer_screen
        self.game_id = None
        self.game_name = None

    def started(self, game_id, game_name):
        self.game_id = game_id
        self.game_name = game_name
        # self.viewer_screen.started(game_id, game_name)

    def frames(self, game_tick, frames):
        for frame in frames:
            for action in frame:
                # {'action': ['f', 1, 1], 'ix': 176, 'tick': 186, 'sprite': 'd64d9bdb-778e-4ce7-b108-b3c590225b0c', 'src': 12, 'score': 176}
                TraceLog.default_logger().trace(
                    'viewer.frames',
                    action['tick'],
                    [0, action['sprite'], ViewerClient.cmd_translate.get(action['action'][0],'unknown'), action['action'][1]]
                )
        # self.viewer_screen.game_status(game_tick, frames)

    def map_status(self, game_tick, map_status):
        game_time = map_status['game_time']
        robos = map_status['robotLines']
        for robo in robos:
            # {'id': '73c71d53-bb1c-43f0-97e4-a20e2d2862be', 'x': 8, 'y': 10, 'dir': 90, 'beacons': 0}
            TraceLog.default_logger().trace('viewer.mapstatus', game_tick, [robo['x'],robo['y']], robo['beacons'], robo['dir'])
        # self.viewer_screen.game_status(game_tick, game_status)


async def screen_timer(scrn, player, loop):
    if scrn.has_key():
        scrn.close()
        await player.stop()
    else:
        scrn.timer()


async def main(loop):
    # create and start viewer
    scrn = aui.ViewerDisplay()
    clnt = ViewerClient(scrn)
    viewer = client.CLIViewer(loop, args.url, clnt)
    timer1 = Timer(1, viewer.timer, True)
    timer2 = Timer(0.05, functools.partial(screen_timer, scrn, viewer, loop), True)
    await viewer.run_game(args.name, args.password)
    timer1.cancel()
    timer2.cancel()

if __name__ == "__main__":
    # get commandline arguments
    parser = argparse.ArgumentParser(description='CommandLineInterface (CLI) for Player')
    parser.add_argument('--url', type=str, default=config.REST_URL, help='url of the robotjes REST entrypoint')
    parser.add_argument('--name', type=str, default="the_game", help='name of the game to view')
    parser.add_argument('--password', type=str, default="secret", help='password needed to enter the game')
    args = parser.parse_args()

    # start our run in main
    aloop = asyncio.get_event_loop()
    try:
        aloop.run_until_complete(main(aloop))
    except:
        pass
    aloop.stop()
