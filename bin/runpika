#!/usr/bin/env python3

import sys, os
import argparse
import pika, json

from robotjes.remote import Handler
from robotjes.sim import Engine, Map


sys.path.insert(0, os.path.abspath(os.getcwd()))

from robotjes.remote import Requestor
from robotjes.bot import Robo, RoboShell

parser = argparse.ArgumentParser(description='Execute a Robomind Academy Python script.')
parser.add_argument('--rmqhost', type=str, default='localhost', help='rabbitmq host')
parser.add_argument('--rmqport', type=int, default=5672, help='rabbitmq port')
parser.add_argument('--rmqqueue', type=str, default='rpc_queue', help='rabbitmq queue to use for rpc calls')
parser.add_argument('--simhost', type=str, default='localhost', help='host used to connect simulation server and client')
parser.add_argument('--simport', type=int, default=9000, help='port on simulation server')
parser.add_argument('--authkey', type=str, default='myownsecret', help='shared secret')
args = parser.parse_args()

# prepare pika (blocking, one RPC queue and a requestor-created reply-to queue)
connection = pika.BlockingConnection(pika.ConnectionParameters(host=args.rmqhost, port=args.rmqport))
channel = connection.channel()
channel.queue_declare(queue=args.rmqqueue)


def run_simulation(mapstr, success, scriptstr):
    """ actually do the work """
    map = Map.fromstring(mapstr)
    script = scriptstr.split('\n')
    engine = Engine(map)
    handler = Handler(args.simhost, args.simport, args.authkey)
    handler.run_client(script)
    handler.run(engine)
    recording = engine.recording
    return recording.toMap()


def on_request(ch, method, props, body):
    """ do the request/run/reply cycle"""
    try:
        request = json.loads(body)
        # do some work
        if "map" in request and "success" in request and "script" in request:
            map = request["map"]
            success = request["success"]
            script = request["script"]
            recording = run_simulation(map, success, script)
            reply = {'recording': recording}
        else:
            reply = {'error': "missing components in request"}
    except json.decoder.JSONDecodeError as jsonerror:
        reply = {'error': str(jsonerror)}
    except Exception as e:
        reply = {'error': str(e)}

    # send back reply over 'reply_to' queue
    ch.basic_publish(exchange='',
                     routing_key=props.reply_to,
                     properties=pika.BasicProperties(correlation_id = props.correlation_id),
                     body=json.dumps(reply))
    ch.basic_ack(delivery_tag=method.delivery_tag)


# start listening for work
channel.basic_qos(prefetch_count=1)
channel.basic_consume(queue=args.rmqqueue, on_message_callback=on_request)
channel.start_consuming()
