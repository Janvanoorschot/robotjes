#!/usr/bin/env python3

import sys, os, uuid
import datetime
import argparse
import pika
import logging.config
import config

modpath = os.path.abspath(os.path.join(os.path.dirname(__file__), os.pardir))
os.chdir(modpath)
sys.path.append(modpath)
ticks_per_second = 10
milliseconds_delta = datetime.timedelta(milliseconds=(1000/ticks_per_second))

# get commandline parameters
parser = argparse.ArgumentParser(description='Execute a Robomind Academy Python script.')
parser.add_argument('--pikaurl', type=str, default=config.PIKA_URL, help='rabbitmq url')
parser.add_argument('--logconf', type=str, default=config.LOG_CONFIG_FILE, help='port')
args = parser.parse_args()

# some constants

# prepare pika
parameters = pika.URLParameters(args.pikaurl)
connection = pika.BlockingConnection(parameters)
channel = connection.channel()
channel.basic_qos(prefetch_count=1)


# prepare monitoring environment (including synchronous loghandler)
import monitor
monitor.mon = monitor.monitor_client.MonitorClient(connection, config.MONITOR_EXCHANGE)
monitor.mon.connect()

# prepare logging
logging.config.fileConfig(args.logconf)
logger = logging.getLogger(__name__)
logger.warning("starting bubble")

# create the Bubble instance.
from bubblehub import Bubble
bubble_id = str(uuid.uuid4())
bubble = Bubble(bubble_id)

# feed the BubbleHub with a Mazes object
from robotjes.sim import Mazes
mazesdir = os.path.join(modpath, "datafiles/mazes")
mazes = Mazes(mazesdir)
bubble.set_mazes(mazes)

bubble.connect(channel)


def timer():
    # we want to do something (the bubble.timer(now) call and then have the
    # next timer-tick to be at the correct time.
    now = datetime.datetime.now()
    next_ping = (now + milliseconds_delta)
    bubble.timer(now)
    sleep_seconds = (next_ping - datetime.datetime.now())/datetime.timedelta(seconds=1)
    if sleep_seconds > 0:
        connection.add_timeout(sleep_seconds, timer)
    else:
        connection.add_timeout(0, timer)


# timer-handling.
# Start at the next whole second (so first wait until the start of the next whole second)
now = datetime.datetime.now()
delta = datetime.timedelta(seconds=1)
next_second = (now + delta).replace(microsecond=0)
wait_seconds = (next_second - now)
connection.add_timeout(wait_seconds/datetime.timedelta(seconds=1), timer)

try:
    channel.start_consuming()
except KeyboardInterrupt:
    channel.stop_consuming()

connection.close()
