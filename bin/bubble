#!/usr/bin/env python3

import sys, os
import argparse
import pika, json
import logging.config
from bubblehub.model import BubbleSpec, ConnectionSpec, BubbleStatus

sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), os.pardir)))

PIKA_URL = 'amqp://guest:guest@localhost:5672/%2F'
BUBBLES_QUEUE = "bubbles_queue"
GAMES_QUEUE = "games_queue"
MONITOR_EXCHANGE = "monitor_exchange"
LOG_CONFIG_FILE = "bin/log.conf"

parser = argparse.ArgumentParser(description='Execute a Robomind Academy Python script.')
parser.add_argument('--pikaurl', type=str, default=PIKA_URL, help='rabbitmq url')
parser.add_argument('--bubblesqueue', type=str, default=BUBBLES_QUEUE, help='rabbitmq queue to use for rpc calls')
parser.add_argument('--gamesqueue', type=str, default=GAMES_QUEUE, help='rabbitmq queue to use for rpc calls')
parser.add_argument('--monitorexchange', type=str, default=MONITOR_EXCHANGE, help='monitor exchange')
parser.add_argument('--logconf', type=str, default=LOG_CONFIG_FILE, help='port')
args = parser.parse_args()

# prepare pika
parameters = pika.URLParameters(args.pikaurl)
connection = pika.BlockingConnection(parameters)
channel = connection.channel()
channel.basic_qos(prefetch_count=1)
bubbles_consumer_tag = None
games_consumer_tag = None

# prepare monitoring environment (including synchronous loghandler)
import monitor
monitor.mon = monitor.monitor_client.MonitorClient(connection, args.monitorexchange)
monitor.mon.connect()

# prepare logging
logging.config.fileConfig(args.logconf)
logger = logging.getLogger(__name__)
logger.warning("starting logger")

# create the BubbleHub class that will handle the requests
from bubblehub import Bubble
bubble = Bubble()

def on_hub_request(ch, method, props, body):
    logger.warning("on_request")
    """ do the request/run/reply cycle"""
    try:
        request = json.loads(body)
        cmd = request.get('cmd', 'unknown')
        if cmd == 'start_game':
            # stop listening to our queue
            channel.basic_cancel(consumer_tag=bubbles_consumer_tag)
            reply = {'success': True}
            print("handled start_game")
        else:
            reply = {'success': False, 'error': f"unknown command: {cmd}"}
    except json.decoder.JSONDecodeError as jsonerror:
        reply = {'success': False, 'error': str(jsonerror)}
    except Exception as e:
        reply = {'success': False, 'error': str(e)}

    # send back reply over 'reply_to' queue
    j = json.dumps(reply)
    ch.basic_publish(exchange='',
                     routing_key=props.reply_to,
                     properties=pika.BasicProperties(correlation_id = props.correlation_id),
                     body=j)
    ch.basic_ack(delivery_tag=method.delivery_tag)

def on_games_request(ch, method, props, body):
    logger.warning("on_games_request")

# start listening for hub's RPC calls
channel.queue_declare(queue=args.bubblesqueue)
bubbles_consumer_tag = channel.basic_consume(queue=args.bubblesqueue, on_message_callback=on_hub_request)
channel.queue_declare(queue=args.gamesqueue)
games_consumer_tag = channel.basic_consume(queue=args.gamesqueue, on_message_callback=on_games_request)
channel.start_consuming()
