#!/usr/bin/env python3

import sys, os, uuid
import threading
import functools
import argparse
import pika, json
import logging.config

sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), os.pardir)))

PIKA_URL = 'amqp://guest:guest@localhost:5672/%2F'
BUBBLES_EXCHANGE = "bubbles_exchange"
BUBBLES_QUEUE = "bubbles_queue"
MONITOR_EXCHANGE = "monitor_exchange"
LOG_CONFIG_FILE = "bin/log.conf"

# get commandline parameters
parser = argparse.ArgumentParser(description='Execute a Robomind Academy Python script.')
parser.add_argument('--pikaurl', type=str, default=PIKA_URL, help='rabbitmq url')
parser.add_argument('--logconf', type=str, default=LOG_CONFIG_FILE, help='port')
args = parser.parse_args()

# prepare pika
parameters = pika.URLParameters(args.pikaurl)
connection = pika.BlockingConnection(parameters)
channel = connection.channel()

# prepare monitoring environment (including synchronous loghandler)
import monitor
monitor.mon = monitor.monitor_client.MonitorClient(connection, MONITOR_EXCHANGE)
monitor.mon.connect()

# prepare logging
logging.config.fileConfig(args.logconf)
logger = logging.getLogger(__name__)
logger.warning("starting logger")

# create the Bubble intance. It's main operation will run on a seperate thread.
from bubblehub import Bubble
bubble_id = str(uuid.uuid4())
bubble = Bubble(bubble_id, channel)


def ack_message(channel, delivery_tag, game_id):
    if channel.is_open:
        # channel.basic_ack(delivery_tag)
        pass
    else:
        pass


def do_work(connection, channel, delivery_tag, body):
    thread_id = threading.get_ident()
    game_id = str(uuid.uuid4())
    bubble.start_game(game_id)
    cb = functools.partial(ack_message, channel, delivery_tag, game_id)
    connection.add_callback_threadsafe(cb)


def on_message(channel, method_frame, header_frame, body, args):
    (connection, threads) = args
    delivery_tag = method_frame.delivery_tag
    reply = None
    try:
        specs = json.loads(body)
        t = threading.Thread(target=do_work, args=(connection, channel, delivery_tag, body))
        t.start()
        threads.append(t)
    except json.decoder.JSONDecodeError as jsonerror:
        reply = {'success': False, 'error': str(jsonerror)}
    except Exception as e:
        reply = {'success': False, 'error': str(e)}

    # send back reply over 'reply_to' queue
    if reply:
        j = json.dumps(reply)
        channel.basic_publish(exchange=BUBBLES_EXCHANGE,
                         routing_key=header_frame.reply_to,
                         properties=pika.BasicProperties(correlation_id = header_frame.correlation_id),
                         body=j)
        channel.basic_ack(delivery_tag=method_frame.delivery_tag)


# start listening for hub's RPC calls
channel.exchange_declare(exchange=BUBBLES_EXCHANGE, exchange_type="direct")
channel.queue_declare(queue=BUBBLES_QUEUE)
channel.queue_bind(queue=BUBBLES_QUEUE, exchange=BUBBLES_EXCHANGE)
channel.basic_qos(prefetch_count=1)

threads = []
on_message_callback = functools.partial(on_message, args=(connection, threads))
channel.basic_consume(BUBBLES_QUEUE,  on_message_callback)

def timer():
    for t in threads:
        pass
    print("timer\n")
    connection.add_timeout(1, timer)

connection.add_timeout(1, timer)

try:
    channel.start_consuming()
except KeyboardInterrupt:
    channel.stop_consuming()

# Wait for all threads before closing the connection
for thread in threads:
    thread.join()

connection.close()
